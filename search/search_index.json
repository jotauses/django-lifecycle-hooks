{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Django Lifecycle Hooks","text":"<p>The elegant, high-performance way to handle Django model events.</p> <p> </p>"},{"location":"#welcome","title":"\ud83d\udc4b Welcome","text":"<p>Django Lifecycle Hooks transforms how you write Django signals. Instead of scattering logic across multiple files and connecting signals manually, you declare your logic right where it belongs: inside your model.</p> <p>It's designed to be: - Intuitive: Read your code and know exactly what happens when. - Fast: Zero runtime overhead for setup; optimized for speed. - Modern: Built for Python 3.14+ and Django 5.2+, with full type safety.</p>"},{"location":"#why-use-this","title":"\u2728 Why use this?","text":""},{"location":"#the-old-way-signals","title":"\ud83d\udeab The Old Way (Signals)","text":"<p><pre><code># signals.py\n@receiver(post_save, sender=User)\ndef send_welcome_email(sender, instance, created, **kwargs):\n    if created:\n        ...\n</code></pre> Logic is separated from the model, hard to track, and often leads to circular imports.</p>"},{"location":"#the-lifecycle-way","title":"\u2705 The Lifecycle Way","text":"<p><pre><code># models.py\nclass User(LifecycleModelMixin, models.Model):\n    @hook(HookType.AFTER_CREATE)\n    def send_welcome_email(self):\n        ...\n</code></pre> Logic is co-located, readable, and declarative.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#1-install","title":"1. Install","text":"<pre><code>pip install django-lifecycle-hooks\n</code></pre>"},{"location":"#2-use","title":"2. Use","text":"<p>Inherit from <code>LifecycleModelMixin</code> and start decorating!</p> <pre><code>from django.db import models\nfrom django_lifecycle_hooks import LifecycleModelMixin, hook, HookType\n\nclass UserAccount(LifecycleModelMixin, models.Model):\n    username = models.CharField(max_length=100)\n    status = models.CharField(max_length=20, default=\"active\")\n\n    @hook(HookType.BEFORE_SAVE)\n    def clean_username(self):\n        self.username = self.username.lower()\n\n    @hook(HookType.AFTER_UPDATE, when=\"status\", was=\"active\", is_now=\"banned\")\n    def on_ban(self):\n        print(f\"User {self.username} has been banned.\")\n</code></pre>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>User Guide: Learn the basics and master advanced patterns.</li> <li>API Reference: Detailed technical documentation.</li> </ul> <p>Crafted with \u2764\ufe0f for the Django community.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section provides detailed technical documentation for the <code>django-lifecycle-hooks</code> API.</p>"},{"location":"api/#decorators","title":"\ud83e\udde9 Decorators","text":""},{"location":"api/#hook","title":"<code>@hook</code>","text":"<p>The core decorator used to register lifecycle methods.</p> <pre><code>def hook(\n    trigger: HookType,\n    when: str | None = None,\n    was: Any = \"*\",\n    is_now: Any = \"*\",\n    has_changed: bool = False,\n    condition: Any = None,\n    priority: int = 0,\n    on_commit: bool = False,\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>trigger</code> <code>HookType</code> Required The lifecycle event to hook into (e.g., <code>HookType.BEFORE_SAVE</code>). <code>when</code> <code>str</code> <code>None</code> The field name to watch. Supports dot notation (e.g., <code>\"author.name\"</code>). <code>was</code> <code>Any</code> <code>\"*\"</code> Execute only if the field's previous value matches this. <code>\"*\"</code> means any value. <code>is_now</code> <code>Any</code> <code>\"*\"</code> Execute only if the field's current value matches this. <code>\"*\"</code> means any value. <code>has_changed</code> <code>bool</code> <code>False</code> If <code>True</code>, execute only if the field's value has changed. <code>condition</code> <code>Condition</code> <code>None</code> An advanced condition object (e.g., <code>WhenFieldHasChanged(...)</code>). <code>priority</code> <code>int</code> <code>0</code> Execution order. Higher values run first. <code>on_commit</code> <code>bool</code> <code>False</code> If <code>True</code>, the hook runs only after the transaction commits successfully."},{"location":"api/#mixins","title":"\ud83c\udfd7\ufe0f Mixins","text":""},{"location":"api/#lifecyclemodelmixin","title":"<code>LifecycleModelMixin</code>","text":"<p>The base mixin that enables lifecycle hooks on your Django models.</p>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#has_changedfield_name-str-bool","title":"<code>has_changed(field_name: str) -&gt; bool</code>","text":"<p>Checks if a field has changed since the instance was loaded or last saved. - Note: Only works for fields that are being watched by at least one hook (Sparse Snapshotting).</p>"},{"location":"api/#initial_valuefield_name-str-any","title":"<code>initial_value(field_name: str) -&gt; Any</code>","text":"<p>Returns the value of the field as it was when the instance was loaded.</p>"},{"location":"api/#current_valuefield_name-str-any","title":"<code>current_value(field_name: str) -&gt; Any</code>","text":"<p>Returns the current value of the field on the instance.</p>"},{"location":"api/#suppress_hooked_methods","title":"<code>suppress_hooked_methods()</code>","text":"<p>A context manager to temporarily disable all lifecycle hooks for the instance.</p> <pre><code>with instance.suppress_hooked_methods():\n    instance.save()\n</code></pre>"},{"location":"api/#enums","title":"\ud83d\udea6 Enums","text":""},{"location":"api/#hooktype","title":"<code>HookType</code>","text":"<p>Defines the available lifecycle events.</p> <ul> <li><code>BEFORE_SAVE</code></li> <li><code>AFTER_SAVE</code></li> <li><code>BEFORE_CREATE</code></li> <li><code>AFTER_CREATE</code></li> <li><code>BEFORE_UPDATE</code></li> <li><code>AFTER_UPDATE</code></li> <li><code>BEFORE_DELETE</code></li> <li><code>AFTER_DELETE</code></li> </ul>"},{"location":"api/#conditions","title":"\ud83e\udde0 Conditions","text":"<p>Condition classes allow for complex logic. They support logical operators: <code>&amp;</code> (AND), <code>|</code> (OR), <code>~</code> (NOT).</p>"},{"location":"api/#whenfieldhaschanged","title":"<code>WhenFieldHasChanged</code>","text":"<p>Checks if a field's value has changed. <pre><code>WhenFieldHasChanged(field_name: str)\n</code></pre></p>"},{"location":"api/#whenfieldvalueis","title":"<code>WhenFieldValueIs</code>","text":"<p>Checks if a field's current value equals the given value. <pre><code>WhenFieldValueIs(field_name: str, value: Any)\n</code></pre></p>"},{"location":"api/#whenfieldvalueisnot","title":"<code>WhenFieldValueIsNot</code>","text":"<p>Checks if a field's current value does not equal the given value. <pre><code>WhenFieldValueIsNot(field_name: str, value: Any)\n</code></pre></p>"},{"location":"api/#whenfieldvaluewas","title":"<code>WhenFieldValueWas</code>","text":"<p>Checks if a field's initial value equals the given value. <pre><code>WhenFieldValueWas(field_name: str, value: Any)\n</code></pre></p>"},{"location":"api/#whenfieldvaluewasnot","title":"<code>WhenFieldValueWasNot</code>","text":"<p>Checks if a field's initial value does not equal the given value. <pre><code>WhenFieldValueWasNot(field_name: str, value: Any)\n</code></pre></p>"},{"location":"api/#whenfieldvaluechangesto","title":"<code>WhenFieldValueChangesTo</code>","text":"<p>Checks if a field has changed AND its new value equals the given value. <pre><code>WhenFieldValueChangesTo(field_name: str, value: Any)\n</code></pre></p>"},{"location":"user-guide/","title":"User Guide","text":"<p>Welcome to the Django Lifecycle Hooks user guide. This document is designed to take you from \"Hello World\" to mastering complex, high-performance lifecycle patterns.</p>"},{"location":"user-guide/#getting-started","title":"\ud83c\udfc1 Getting Started","text":""},{"location":"user-guide/#installation","title":"Installation","text":"<pre><code>pip install django-lifecycle-hooks\n</code></pre>"},{"location":"user-guide/#the-basics","title":"The Basics","text":"<p>To start using lifecycle hooks, you only need two things: 1.  Inherit from <code>LifecycleModelMixin</code>. 2.  Use the <code>@hook</code> decorator.</p> <pre><code>from django.db import models\nfrom django_lifecycle_hooks import LifecycleModelMixin, hook, HookType\n\nclass Article(LifecycleModelMixin, models.Model):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(blank=True)\n    status = models.CharField(max_length=20, default=\"draft\")\n\n    @hook(HookType.BEFORE_SAVE)\n    def generate_slug(self):\n        if not self.slug:\n            self.slug = slugify(self.title)\n</code></pre>"},{"location":"user-guide/#hook-triggers","title":"\ud83c\udfaf Hook Triggers","text":"<p>The library supports all standard Django model events.</p> Trigger Description <code>BEFORE_SAVE</code> Runs before <code>save()</code>. Ideal for data validation or normalization. <code>AFTER_SAVE</code> Runs after <code>save()</code>. Ideal for side effects (emails, indexing). <code>BEFORE_CREATE</code> Runs before <code>save()</code>, but only if it's a new record. <code>AFTER_CREATE</code> Runs after <code>save()</code>, but only if it's a new record. <code>BEFORE_UPDATE</code> Runs before <code>save()</code>, but only if updating an existing record. <code>AFTER_UPDATE</code> Runs after <code>save()</code>, but only if updating an existing record. <code>BEFORE_DELETE</code> Runs before <code>delete()</code>. <code>AFTER_DELETE</code> Runs after <code>delete()</code>."},{"location":"user-guide/#conditional-execution","title":"\ud83e\udde0 Conditional Execution","text":"<p>The real power of this library lies in its ability to run hooks only when specific conditions are met.</p>"},{"location":"user-guide/#simple-conditions-arguments","title":"Simple Conditions (Arguments)","text":"<p>You can filter execution using arguments directly in the <code>@hook</code> decorator.</p>"},{"location":"user-guide/#1-when-field-watching","title":"1. <code>when</code> (Field Watching)","text":"<p>Run only if a specific field is involved.</p> <pre><code>@hook(HookType.BEFORE_SAVE, when=\"status\")\ndef on_status_touch(self):\n    print(\"Status field is being saved!\")\n</code></pre>"},{"location":"user-guide/#2-has_changed","title":"2. <code>has_changed</code>","text":"<p>Run only if the field's value has actually changed.</p> <pre><code>@hook(HookType.BEFORE_SAVE, when=\"status\", has_changed=True)\ndef on_status_change(self):\n    # Runs if status goes from 'draft' -&gt; 'published'\n    # Does NOT run if status goes from 'draft' -&gt; 'draft'\n    pass\n</code></pre>"},{"location":"user-guide/#3-was-and-is_now-value-matching","title":"3. <code>was</code> and <code>is_now</code> (Value Matching)","text":"<p>Run only if the field matches specific values.</p> <pre><code>@hook(HookType.AFTER_UPDATE, when=\"status\", was=\"draft\", is_now=\"published\")\ndef publish_article(self):\n    print(\"Article just got published!\")\n</code></pre>"},{"location":"user-guide/#advanced-conditions-classes","title":"Advanced Conditions (Classes)","text":"<p>For complex logic, use Condition classes. You can combine them using logical operators: <code>&amp;</code> (AND), <code>|</code> (OR), <code>~</code> (NOT).</p> <pre><code>from django_lifecycle_hooks import (\n    WhenFieldHasChanged, \n    WhenFieldValueIs, \n    WhenFieldValueChangesTo\n)\n\nclass Order(LifecycleModelMixin, models.Model):\n    status = models.CharField(...)\n    is_paid = models.BooleanField(...)\n\n    # Run if status changes to 'shipped' AND the order is paid\n    @hook(HookType.AFTER_SAVE, condition=(\n        WhenFieldValueChangesTo(\"status\", \"shipped\") &amp; \n        WhenFieldValueIs(\"is_paid\", True)\n    ))\n    def ship_order(self):\n        ...\n</code></pre> <p>Available Conditions: - <code>WhenFieldHasChanged(field)</code> - <code>WhenFieldValueIs(field, value)</code> - <code>WhenFieldValueIsNot(field, value)</code> - <code>WhenFieldValueWas(field, value)</code> - <code>WhenFieldValueWasNot(field, value)</code> - <code>WhenFieldValueChangesTo(field, value)</code></p>"},{"location":"user-guide/#async-asgi-support","title":"\u26a1 Async &amp; ASGI Support","text":"<p>We are the only lifecycle library with first-class Async support.</p>"},{"location":"user-guide/#using-asave-and-acreate","title":"Using <code>asave</code> and <code>acreate</code>","text":"<p>When you use Django's async methods, your hooks run automatically.</p> <pre><code># This will trigger all your hooks, just like synchronous save()\nawait article.asave()\nawait Article.objects.acreate(title=\"Async Article\")\n</code></pre>"},{"location":"user-guide/#writing-async-hooks","title":"Writing Async Hooks","text":"<p>You can define hooks as <code>async def</code>. They will be awaited properly when using <code>asave()</code>.</p> <pre><code>@hook(HookType.AFTER_SAVE)\nasync def send_notification(self):\n    # Fully non-blocking!\n    await email_service.send_async(...)\n</code></pre> <p>Note: If you call <code>save()</code> (sync) on a model with async hooks, the async hooks are skipped to prevent runtime errors. Always use <code>asave()</code> if you have async logic.</p>"},{"location":"user-guide/#transaction-safety","title":"\ud83d\udee1\ufe0f Transaction Safety","text":"<p>Side effects like sending emails or charging credit cards should only happen if the database transaction succeeds.</p> <p>Use <code>on_commit=True</code> to defer execution until the transaction commits.</p> <pre><code>@hook(HookType.AFTER_SAVE, on_commit=True)\ndef charge_card(self):\n    # This runs ONLY after the DB transaction is fully committed.\n    payment_gateway.charge(...)\n</code></pre>"},{"location":"user-guide/#inspecting-state","title":"\ud83d\udd0d Inspecting State","text":"<p>Sometimes you need to check state manually inside your methods.</p> <pre><code>def my_custom_logic(self):\n    if self.has_changed(\"status\"):\n        old = self.initial_value(\"status\")\n        new = self.current_value(\"status\")\n        print(f\"Changed from {old} to {new}\")\n</code></pre> <ul> <li><code>self.has_changed(field)</code>: Returns <code>True</code> if the field changed.</li> <li><code>self.initial_value(field)</code>: Returns the value from when the instance was loaded.</li> <li><code>self.current_value(field)</code>: Returns the current value.</li> </ul>"},{"location":"user-guide/#advanced-patterns","title":"\ud83d\udee0\ufe0f Advanced Patterns","text":""},{"location":"user-guide/#watching-related-fields","title":"Watching Related Fields","text":"<p>You can watch fields on related models using dot notation.</p> <pre><code>class Book(LifecycleModelMixin, models.Model):\n    author = models.ForeignKey(Author, ...)\n\n    # Runs if the author's name changes!\n    @hook(HookType.BEFORE_SAVE, when=\"author.name\", has_changed=True)\n    def on_author_rename(self):\n        ...\n</code></pre>"},{"location":"user-guide/#stacked-hooks","title":"Stacked Hooks","text":"<p>You can attach multiple hooks to the same method.</p> <pre><code>@hook(HookType.AFTER_CREATE)\n@hook(HookType.AFTER_UPDATE, when=\"status\", has_changed=True)\ndef update_search_index(self):\n    # Runs on creation OR when status changes\n    index.update(self)\n</code></pre>"},{"location":"user-guide/#suppressing-hooks","title":"Suppressing Hooks","text":"<p>Need to bulk update without triggering hooks? Use the context manager.</p> <pre><code>with instance.suppress_hooked_methods():\n    instance.status = \"maintenance\"\n    instance.save()  # No hooks will fire\n</code></pre>"},{"location":"user-guide/#introspection","title":"Introspection","text":"<p>See exactly what hooks are registered on your model.</p> <pre><code>python manage.py list_hooks\n</code></pre>"},{"location":"user-guide/#common-gotchas","title":"\u26a0\ufe0f Common Gotchas","text":"<ol> <li><code>update_fields</code> Optimization: If you save with <code>save(update_fields=['status'])</code>, hooks watching other fields (e.g., <code>title</code>) will be skipped for performance.</li> <li>Bulk Operations: Django's <code>queryset.update()</code> and <code>queryset.bulk_create()</code> do NOT call <code>save()</code>, so they do NOT trigger hooks. This is standard Django behavior.</li> <li>Async Mixing: Async hooks (<code>async def</code>) only run during <code>asave()</code>. Sync hooks (<code>def</code>) run during both <code>save()</code> and <code>asave()</code>.</li> </ol>"}]}